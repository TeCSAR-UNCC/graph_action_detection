#!/usr/bin/python3
import sys
import os
import scipy.io as sci
import cv2
import numpy as np
from tqdm import tqdm
from PIL import Image
import subprocess
from scipy import stats
import argparse

import os
import time
import numpy as np
import yaml
import pickle
from collections import OrderedDict

import torch
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt
from torch.autograd import Variable

from src import Options
from src import BBoxExtractor as bbe
from src.EdgeNode import EdgeNode
from src.EdgeServer import EdgeServer
from src.MobileNetKeypoints.MobileNetKeypointExtractor import MobileNetKeypoints
from src.EfficientHRNetKeypoints.EfficientHRNetKeypointExtractor import EfficientHRNetKeypoints
from src.ReIDFeatureExtractor.ReIDFeatureEncoder import FeatureEncoder
from src.EfficientHRNetKeypoints.config import pose_cfg, check_config, update_config
from src.EfficientSegNet.config import seg_cfg, seg_update_config
from src.EfficientSegNet.EfficientSegmentation import EfficientSegNet
from actionGraph import KeyProcessor


use_EfficientHRNet = True
use_EfficientSegNet = False
'''
def parse_args():
    parser = argparse.ArgumentParser(description='Inference EfficientHRNet Pose')
    # general
    parser.add_argument('--cfg',
                        help='experiment configure file name',
                        required=False,
                        default='src/EfficientHRNetKeypoints/config.yaml',
                        type=str)
    
    parser.add_argument('--image',
                        help='path to image for inference',
                        required=True,
                        type=str)

    parser.add_argument('opts',
                        help="Modify config options using the command-line",
                        default=None,
                        nargs=argparse.REMAINDER)
    
    args = parser.parse_args()

    return args
'''
def postSimValidation(validation_table):
    print()
    num_gt_ids = validation_table.shape[0]
    gt_appearance_count = np.count_nonzero(validation_table, axis=1)
    ids_per_row = []

    # Find all of the unique IDs generated by the system
    valid_ids = validation_table[np.nonzero(validation_table>0)]
    unique_ids = np.unique(valid_ids)

    # Generate GT-System ID Match Table
    print("Matching system IDs to ground truth IDs...")
    mode_table = np.zeros((num_gt_ids, unique_ids.size),dtype=int)
    print("Constructing GT-System ID match table...")
    for i in tqdm(range(num_gt_ids)):
        id_row = validation_table[i,:]
        if gt_appearance_count[i] > 0:
            ids_in_row = np.unique(id_row[np.nonzero(id_row > 0)])
            ids_per_row.append(ids_in_row.size)
        for j in range(unique_ids.size):
            unique_id = unique_ids[j]
            mode_table[i,j] = np.count_nonzero(id_row==unique_id)

    # Find the ID modes to assign a system ID to each GT ID
    id_modes = np.full((num_gt_ids,2), -2, dtype=int)
    id_modes[:,1] = np.zeros((id_modes[:,1].shape), dtype=int)
    tab_max = mode_table.max()
    print("Matching IDs...")
    while tab_max > 0:
        match_pos = np.where(mode_table==tab_max)
        gt_idx = match_pos[0][0]
        system_id_idx = match_pos[1][0]
        system_id = unique_ids[match_pos[1][0]]
        id_modes[gt_idx,0] = system_id
        id_modes[gt_idx,1] = tab_max

        mode_table[gt_idx,:] = np.zeros(mode_table[gt_idx,:].shape, dtype=int)
        mode_table[:,system_id_idx] = np.zeros(mode_table[:,system_id_idx].shape, dtype=int)
        tab_max = mode_table.max()
    
    print("Calculating Re-ID statistics...")
    ids_per_row = np.array(ids_per_row, dtype=float)
    IDTP = np.zeros((num_gt_ids,1),dtype=float)
    IDFP = np.zeros((num_gt_ids,1),dtype=float)
    IDFN = np.zeros((num_gt_ids,1),dtype=float)
    for i in tqdm(range(num_gt_ids)):
        IDTP[i] = id_modes[i,1]
        matched_id = id_modes[i,0]
        IDFP[i] = np.count_nonzero(validation_table==matched_id) - IDTP[i]
        IDFN[i] = gt_appearance_count[i] - IDTP[i]

    valid = np.where(gt_appearance_count>0)
    IDP = IDTP[valid] / (IDTP[valid] + IDFP[valid] + 0.000001)
    IDR = IDTP[valid] / (IDTP[valid] + IDFN[valid] + 0.000001)
    IDF1 = (2 * IDTP[valid]) / (2 * IDTP[valid] + IDFP[valid] + IDFN[valid] + 0.000001)

    AvgIDP = np.mean(IDP)
    AvgIDR = np.mean(IDR)
    AvgIDF1 = np.mean(IDF1)
    AvgIDPT = np.mean(ids_per_row)

    output_stats = "IDP: " + str(AvgIDP) + " IDR: " + str(AvgIDR) + " IDF1: " + str(AvgIDF1) + " IDs per Target: " + str(AvgIDPT)
    print(output_stats)

def main():
    opts = Options.parseOptions()
    parser = Options.ActionGet_parser()

    # load arg form config file
    p = parser.parse_args()
    if p.config is not None:
        with open(p.config, 'r') as f:
            default_arg = yaml.load(f)
        key = vars(p).keys()
        for k in default_arg.keys():
            if k not in key:
                print('WRONG ARG: {}'.format(k))
                assert (k in key)
        parser.set_defaults(**default_arg)
    Actionarg = parser.parse_args()
    Keyprocessor = KeyProcessor(Actionarg)

    update_config(pose_cfg, opts)
    check_config(pose_cfg)
    seg_update_config(seg_cfg,opts)
    #cfg.defrost()
    #cfg.RANK = 0
    #cfg.freeze()

    cameras = opts.cameras

    if (opts.sequence[0]==-1):
        sequence_ends = np.array([999999,0])
    else:
        sequence_ends = np.array(opts.sequence)

    edge_nodes = []

    os.environ["CUDA_VISIBLE_DEVICES"] = str(opts.use_gpu)
    if opts.openpose_path:
        os.environ["EDGE_ANALYTICS"] = opts.openpose_path
    using_gpu = (opts.use_gpu != -1)

    if (opts.eval_set % 2 == 1) and opts.openpose_path:
        for cam in cameras:
            pose_path = opts.json_path + '/camera' + str(cam)
            image_dir = opts.image_path + '/camera' + str(cam)
            openpose_bin = os.getenv("EDGE_ANALYTICS") + '/build/examples/openpose/openpose.bin'
            openpose_args = [openpose_bin,'--image_dir',image_dir,'--render_pose','0','--keypoint_scale','3','--write_json',pose_path,'--display','0']
            if subprocess.call(openpose_args, cwd=os.getenv("EDGE_ANALYTICS")) != 0:
                return

    if use_EfficientSegNet:
        seg_frontend_net = EfficientSegNet(seg_cfg)
    else:
        seg_frontend_net = None
    if use_EfficientHRNet:
        frontend_net = EfficientHRNetKeypoints(pose_cfg)
    else:
        frontend_net = MobileNetKeypoints('./src/MobileNetKeypoints/default_checkpoints/checkpoint_iter_245000.pth', using_gpu)
        
    id_encoder = FeatureEncoder('./src/ReIDFeatureExtractor/model/mobilenetV2.pt', using_gpu)
    
    max_feats_per_id = 10

    validation_table = np.zeros(1, dtype=int)

    # We are not running on video streams and have a GT to validate
    if (opts.eval_set < 2):
        gt_mat_struct = sci.loadmat(opts.ground_truth)
        gt_mat = gt_mat_struct['mtmc_gt']
        # gt_mat structure is [Camera, ID, Frame, X, Y, W, H]

        gt_ids = np.unique(gt_mat[:,1])
        
        for cam in cameras:
            cam_frames = gt_mat[np.where(gt_mat[:,0]==cam),2]
            if opts.sequence[0] == -1:
                if (cam_frames.min(1) < sequence_ends[0]):
                    sequence_ends[0] = cam_frames.min(1)
                if (cam_frames.max(1) > sequence_ends[1]):
                    sequence_ends[1] = cam_frames.max(1)
            edge_nodes.append(EdgeNode(cam, opts, frontend_net, seg_frontend_net,id_encoder, max_feats_per_id, gt_mat[np.where(gt_mat[:,0]==cam),:]))
    else:
        for cam in cameras:
            edge_nodes.append(EdgeNode(cam,opts, frontend_net, Keyprocessor,seg_frontend_net, id_encoder, max_feats_per_id))
    if (opts.source_framerate <= opts.framerate):
        frame_interval = 1
    else:
        frame_interval = opts.source_framerate / opts.framerate
    sequence = np.arange(sequence_ends[0], sequence_ends[1], frame_interval)

    if (opts.eval_set < 2):
        validation_table = np.zeros((len(gt_ids),len(sequence)), dtype=int)

    server = EdgeServer(opts, edge_nodes, max_feats_per_id)

    print("Starting simulation...")
    for i,frame in tqdm(np.ndenumerate(sequence), total=len(sequence)):
        for node in edge_nodes:
            cam_val = node.processFrame(int(frame))
            if (opts.eval_set < 2) and (len(cam_val) > 0):
                for gt_val in cam_val:
                    gt_id = gt_val[0]
                    system_id = gt_val[1]
                    val_tab_idxs = np.where(gt_ids==gt_id)
                    validation_table[val_tab_idxs[0],i] = system_id
        if opts.enable_edge_server != 0:
            server.process_node_data()
    print(len(server.table))
    # Perform post-simulation validation
    if (opts.eval_set < 2):
        postSimValidation(validation_table)

    print('Done')
    
if __name__ == '__main__':
    main()
